<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Downtown Brooklyn Animation</title>
  <style>
    body {
      margin: 0;
      background: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
      font-family: sans-serif;
    }

    svg {
      width: 300px;
      height: 300px;
    }

    polygon {

    }

    .text-block {
      margin-top: -60px;
      text-align: left;
      font-size: 28px;
      font-weight: bold;
      color: #190606;
      line-height: 1.2;
      position: relative;
    }

    .highlight-wrapper {
      display: inline-block;
      position: relative;
      width: 220px;
      height: 36px;
      overflow: hidden;
    }

    .highlight {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
    }
    .final-line {
      display: flex;
      justify-content: flex-start;
      gap: 10px;
    }
  </style>
</head>
<body>

<div style="display: flex; flex-direction: column; align-items: left; gap: 0px;">
  <svg viewBox="0 0 200 200">
  <polygon id="panel" points="0,50 200,30 200,136 0,120" fill="#b7cd3c" />
  </svg>

  <div class="text-block">
    Creating a<br />
    Downtown<br />
    <div class="final-line">
      for 
      <span class="highlight-wrapper">
        <span class="highlight" id="word" style="color:#b7cd3c;">People</span>
      </span>
    </div>
  </div>
</div>

<script src="https://unpkg.com/gsap@3"></script>
<script>
  const polygon = document.querySelector("#panel");
  const wordEl = document.getElementById("word");

  const words = ["People", "Business", "Culture", "Education", "Retail"];
  let wordIndex = 0;

  // === RANGE VARIABLES ===
  const leftTopY     = { min: 24, max: 80 };
  const leftBottomY  = { min: 115, max: 128 };
  const rightTopY    = { min: 12, max: 60 };
  const rightBottomY = { min: 134, max: 136 };

  // === SHAPE POINTS ===
  const p1 = { x: 0, y: 50 };
  const p2 = { x: 120, y: 30 };
  const p3 = { x: 120, y: 136 };
  const p4 = { x: 0, y: 120 };

  function updatePolygon() {
    polygon.setAttribute(
      "points",
      `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y} ${p4.x},${p4.y}`
    );
  }

  function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function cycleWord() {
    wordIndex = (wordIndex + 1) % words.length;
    wordEl.textContent = words[wordIndex];

    // Alternate morphing left or right side each time
    if (wordIndex % 2 === 0) {
      // Morph right side
      gsap.to([p2, p3], {
        duration: morphDuration,
        y: (i) => i === 0 ? random(rightTopY.min, rightTopY.max) : random(rightBottomY.min, rightBottomY.max),
        onUpdate: updatePolygon
      });
    } else {
      // Morph left side
      gsap.to([p1, p4], {
        duration: morphDuration,
        y: (i) => i === 0 ? random(leftTopY.min, leftTopY.max) : random(leftBottomY.min, leftBottomY.max),
        onUpdate: updatePolygon
      });
    }

    const fadeInDuration = morphDuration * 0.8; // 80% of morphDuration
    const pauseDuration = morphDuration * 0.1; // 10% of morphDuration
    const fadeOutDuration = morphDuration * 0.1; // 10% of morphDuration

    const tl = gsap.timeline();
    tl.set(wordEl, { opacity: 0, y: 20 });
    tl.to(wordEl, { opacity: 1, y: 0, duration: fadeInDuration, ease: "power2.out" });
    tl.to(wordEl, { duration: pauseDuration }); // pause
    tl.to(wordEl, { opacity: 0, y: -20, duration: fadeOutDuration, ease: "power2.inOut" });

    return tl;
}

const morphDuration = 3;

const fillColors = [
  "#E6D045", "#B7D342", "#78B64A", "#589F59", "#05B1D7", "#325EB9", "#2141AD", "#51306F",
  "#E81669", "#96364D", "#BB3235", "#EB2127", "#D24835", "#DD672F", "#F69121", "#FFD212"
];
let fillIndex = 0;

function cycleFill() {
  fillIndex = (fillIndex + 1) % fillColors.length;
  const nextFill = fillColors[fillIndex];

  gsap.to(polygon, {
    duration: morphDuration,
    fill: nextFill,
    ease: "power2.inOut"
  });
  gsap.to(document.querySelector('.highlight'), {
    duration: morphDuration,
    color: nextFill,
    ease: "power2.inOut"
  });
}

function animateRightExpand() {
  cycleWord();
  cycleFill(); // Add fill color change
  gsap.to([p2, p3], {
    duration: morphDuration,
    ease: "power2.inOut",
    y: (i) => i === 0 ? random(rightTopY.min, rightTopY.max) : random(rightBottomY.min, rightBottomY.max),
    onUpdate: updatePolygon,
    onComplete: animateLeftShrink
  });
}

function animateLeftShrink() {
  cycleWord();
  cycleFill(); // Add fill color change
  gsap.to([p1, p4], {
    duration: morphDuration,
    ease: "power2.inOut",
    y: (i) => i === 0 ? random(leftTopY.max - 10, leftTopY.max) : random(leftBottomY.min, leftBottomY.min + 10),
    onUpdate: updatePolygon,
    onComplete: animateLeftExpand
  });
}

function animateLeftExpand() {
  cycleWord();
  cycleFill(); // Add fill color change
  gsap.to([p1, p4], {
    duration: morphDuration,
    ease: "power2.inOut",
    y: (i) => i === 0 ? random(leftTopY.min, leftTopY.min + 10) : random(leftBottomY.max - 10, leftBottomY.max),
    onUpdate: updatePolygon,
    onComplete: animateRightShrink
  });
}

function animateRightShrink() {
  cycleWord();
  cycleFill(); // Add fill color change
  gsap.to([p2, p3], {
    duration: morphDuration,
    ease: "power2.inOut",
    y: (i) => i === 0 ? random(rightTopY.max - 10, rightTopY.max) : random(rightBottomY.min, rightBottomY.min + 10),
    onUpdate: updatePolygon,
    onComplete: animateRightExpand
  });
}

  updatePolygon();
  animateRightExpand();
</script>

</body>
</html>